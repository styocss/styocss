import type { IntegrationContext } from './types'
import * as prettier from 'prettier'

function formatUnionStringType(list: (string | number)[]) {
	return list.length > 0 ? list.map(i => typeof i === 'number' ? i : `'${i}'`).join(' | ') : 'never'
}

function generateAutocomplete(ctx: IntegrationContext) {
	const autocomplete = ctx.engine.config.autocomplete
	return [
		'export interface Autocomplete extends _Autocomplete {',
		`  Selector: ${formatUnionStringType([...autocomplete.selectors])}`,
		`  StyleItemString: ${formatUnionStringType([...autocomplete.styleItemStrings])}`,
		`  ExtraProperty: ${formatUnionStringType([...autocomplete.extraProperties])}`,
		`  ExtraCssProperty: ${formatUnionStringType([...autocomplete.extraCssProperties])}`,
		`  PropertiesValue: { ${Array.from(autocomplete.properties.entries(), ([k, v]) => `'${k}': ${v.join(' | ')}`).join(',')} }`,
		`  CssPropertiesValue: { ${Array.from(autocomplete.cssProperties.entries(), ([k, v]) => `'${k}': ${formatUnionStringType(v)}`).join(',')} }`,
		'}',
		'',
	]
}

function generateStyleFn(ctx: IntegrationContext) {
	const { transformedFormat } = ctx
	const lines: string[] = [
		'type StyleFn_Array = (...params: StyleItem<Autocomplete>[]) => string[]',
		'type StyleFn_String = (...params: StyleItem<Autocomplete>[]) => string',
		'type StyleFn_Inline = (...params: StyleItem<Autocomplete>[]) => void',
	]

	if (transformedFormat === 'array')
		lines.push('type StyleFn_Normal = StyleFn_Array')
	else if (transformedFormat === 'string')
		lines.push('type StyleFn_Normal = StyleFn_String')
	else if (transformedFormat === 'inline')
		lines.push('type StyleFn_Normal = StyleFn_Inline')

	lines.push(
		'type StyleFn = StyleFn_Normal & {',
		'  str: StyleFn_String',
		'  arr: StyleFn_Array',
		'  inl: StyleFn_Inline',
		'}',
		`type StyleFnWithPreview = PreviewOverloads<StyleFn_Normal>[\'fn\'] & {`,
		`  str: PreviewOverloads<StyleFn_String>[\'fn\']`,
		`  arr: PreviewOverloads<StyleFn_Array>[\'fn\']`,
		`  inl: PreviewOverloads<StyleFn_Inline>[\'fn\']`,
		'}',
		'',
	)

	return lines
}

function generateGlobalDeclaration(ctx: IntegrationContext) {
	const { fnName } = ctx
	return [
		'declare global {',
		'  /**',
		'   * PikaCSS',
		'   */',
		`  const ${fnName}: StyleFn`,
		'',
		'  /**',
		'   * PikaCSS Preview',
		'   */',
		`  const ${fnName}p: StyleFnWithPreview`,
		'}',
		'',
	]
}

function generateVueDeclaration(ctx: IntegrationContext) {
	const { hasVue, fnName } = ctx

	if (!hasVue)
		return []

	return [
		'declare module \'vue\' {',
		'  interface ComponentCustomProperties {',
		'    /**',
		'     * PikaCSS',
		'     */',
		`    ${fnName}: StyleFn`,
		'',
		'    /**',
		'     * PikaCSS Preview',
		'     */',
		`    ${fnName}p: StyleFnWithPreview`,
		'  }',
		'}',
		'',
	]
}

async function generateOverloadContent(ctx: IntegrationContext) {
	const paramsLines: string[] = []
	const fnsLines: string[] = []
	const usages = [...ctx.usages.values()].flat()

	for (let i = 0; i < usages.length; i++) {
		const usage = usages[i]!
		try {
			const addedParamsLines = usage.params.map((param, index) => `type P${i}_${index} = ${JSON.stringify(param)}`)
			const addedFnLines = [
				'  /**',
				'   * ### PikaCSS Preview',
				'   * ```css',
				// CSS Lines
				...(await prettier.format(await ctx.engine.renderPreviewStyles(...usage.params), { parser: 'css' }))
					.split('\n')
					.map(line => `   * ‎${line.replace(/^(\s*)/, '$1‎')}`),
				'   * ```',
				'   */',
				`  fn(...params: [${usage.params.map((_, index) => `p${index}: P${i}_${index}`).join(', ')}]): ReturnType<StyleFn>`,
			]

			paramsLines.push(...addedParamsLines)
			fnsLines.push(...addedFnLines)
		}
		catch {}
	}

	return [
		'interface PreviewOverloads<StyleFn extends (StyleFn_Array | StyleFn_String | StyleFn_Inline)> {',
		...fnsLines,
		'  /**',
		'   * PikaCSS Preview',
		'   * Save the current file to see the preview.',
		'   */',
		`  fn(...params: Parameters<StyleFn>): ReturnType<StyleFn>`,
		'}',
		...paramsLines,
	]
}

export async function generateTsCodegenContent(ctx: IntegrationContext) {
	const lines = [
		`// Auto-generated by ${ctx.currentPackageName}`,
		`import type { Autocomplete as _Autocomplete, StyleItem } from \'${ctx.currentPackageName}\'`,
		`import { createDefineEngineConfigFn } from \'${ctx.currentPackageName}\'`,
		'',
	]

	lines.push(...generateAutocomplete(ctx))

	lines.push(
		'export const defineEngineConfig: ReturnType<typeof createDefineEngineConfigFn<Autocomplete>> = createDefineEngineConfigFn<Autocomplete>()',
		'',
	)

	lines.push(...generateStyleFn(ctx))
	lines.push(...generateGlobalDeclaration(ctx))
	lines.push(...generateVueDeclaration(ctx))
	lines.push(...await generateOverloadContent(ctx))

	return lines.join('\n')
}
